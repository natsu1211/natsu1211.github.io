<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EverSummer</title>
  
  <subtitle>no game no life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://natsu1211.com/"/>
  <updated>2018-08-25T14:53:53.261Z</updated>
  <id>http://natsu1211.com/</id>
  
  <author>
    <name>natsu1211</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读薄Effective Modern C++ (Item1)</title>
    <link href="http://natsu1211.com/2018/08/24/modern_c++_1/"/>
    <id>http://natsu1211.com/2018/08/24/modern_c++_1/</id>
    <published>2018-08-23T16:27:34.000Z</published>
    <updated>2018-08-25T14:53:53.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="item1-理解模板类型推导p9-p18">Item1 理解模板类型推导（p9-p18）</h2><p>C++98中，类型推导只发生在函数模板中。C++11中类型推导还会发生在大多数auto关键字和decltype表达式出现的地方，C++14还会发生在decltype(auto)。如果对类型推导没有深刻的理解，很难写出高效率的现代C++代码。<br>对于以下函数模板声明（伪代码）， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure></p><p>以及它的调用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f(expr)</span><br></pre></td></tr></table></figure></p><p>在编译时，编译器使用传递来的expr推导出T和ParamType，通常T和ParamType不是一个类型，因为ParamType通常会带上类型修饰符。例如 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">f(x);</span><br><span class="line"><span class="comment">// T is int, ParamType is const int&amp;</span></span><br></pre></td></tr></table></figure></p><p>T的类型由expr和ParamType共同来决定，有3种可能，<br>1. ParamType是一个指针或者引用，但是不是一个通用引用（Universal Reference）<br>2. ParamType是一个通用引用<br>3. ParamType不是指针也不是引用</p><p>对于1，如果expr的类型是个引用，忽略引用的部分。然后利用expr的类型和ParamType对比去判断T的类型。<br>例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;           <span class="comment">// param是一个引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;                 <span class="comment">// x是一个int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;           <span class="comment">// cx是一个const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;          <span class="comment">// rx是const int的引用</span></span><br><span class="line"></span><br><span class="line">f(x);                       <span class="comment">// T是int，param的类型时int&amp;</span></span><br><span class="line"></span><br><span class="line">f(cx);                      <span class="comment">// T是const int，</span></span><br><span class="line">                            <span class="comment">// param的类型是const int&amp;</span></span><br><span class="line">f(rx);                      <span class="comment">// T是const int</span></span><br><span class="line">                            <span class="comment">// param的类型时const int&amp;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;           <span class="comment">// param是一个指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;                 <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;         <span class="comment">// px是一个指向const int x的指针</span></span><br><span class="line"></span><br><span class="line">f(&amp;x);                      <span class="comment">// T是int，param的类型是int*</span></span><br><span class="line"></span><br><span class="line">f(px);                      <span class="comment">// T是const int</span></span><br><span class="line">                            <span class="comment">// param的类型时const int*</span></span><br></pre></td></tr></table></figure><p>对于2，如果expr是一个左值，T和ParamType都会被推导成左值引用。这是模板类型T被推导成一个引用的唯一情况。如果expr是一个右值，那么就执行“普通”的法则（第一种情况）。Item23和Item24会对这种情况进行详尽的解释。<br>例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// param现在是一个通用的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;                 <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;           <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;          <span class="comment">// 和之前一样</span></span><br><span class="line"></span><br><span class="line">f(x);                       <span class="comment">// x是左值，所以T是int&amp;</span></span><br><span class="line">                            <span class="comment">// param的类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line">f(cx);                      <span class="comment">// cx是左值，所以T是const int&amp;</span></span><br><span class="line">                            <span class="comment">// param的类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line">f(rx);                      <span class="comment">// rx是左值，所以T是const int&amp;</span></span><br><span class="line">                            <span class="comment">// param的类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">27</span>);                      <span class="comment">// 27是右值，所以T是int</span></span><br><span class="line">                            <span class="comment">// 所以param的类型是int&amp;&amp;</span></span><br></pre></td></tr></table></figure></p><p>对于3，param是pass-by-value的，这意味着param是的一份全新的拷贝。和之前一样，如果expr的类型是个引用，将会忽略引用的部分。接下来const，volatile修饰符也要忽略掉。这是有道理的，因为传递过来的参数不能修改不代表它的拷贝不能被修改。<br>例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;                 <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;           <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;          <span class="comment">// 和之前一样</span></span><br><span class="line"></span><br><span class="line">f(x);                       <span class="comment">// T和param的类型都是int</span></span><br><span class="line"></span><br><span class="line">f(cx);                      <span class="comment">// T和param的类型也都是int</span></span><br><span class="line"></span><br><span class="line">f(rx);                      <span class="comment">// T和param的类型还都是int</span></span><br></pre></td></tr></table></figure></p><h3 id="注意事项">注意事项</h3><h4 id="数组作为参数">数组作为参数</h4><p>通常情况下数组类型会退化为指针类型，但是在模板函数的参数是数组的引用的时候情况就不同了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;                   <span class="comment">// 引用参数的模板</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"J. P. Briggs"</span>;</span><br><span class="line">f(name);                            <span class="comment">// 传递数组给f</span></span><br></pre></td></tr></table></figure></p><p>T最后推导出来的实际的类型就是数组。类型推导包括了数组的长度，所以在这个例子里面，T被推导成了const char [13]，函数f的参数（数组的引用）被推导成了const char (&amp;)[13]。<br>#### 函数作为参数 函数也会退化为函数指针， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>， <span class="keyword">double</span>)</span></span>;    <span class="comment">// someFunc是一个函数</span></span><br><span class="line">                                <span class="comment">// 类型是void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;               <span class="comment">// 在f1中 参数直接按值传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;              <span class="comment">// 在f2中 参数是按照引用传递</span></span><br><span class="line"></span><br><span class="line">f1(someFunc);                   <span class="comment">// param被推导成函数指针</span></span><br><span class="line">                                <span class="comment">// 类型是void(*)(int, double)</span></span><br><span class="line"></span><br><span class="line">f2(someFunc);                   <span class="comment">// param被推导成函数引用</span></span><br><span class="line">                                <span class="comment">// 类型是void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure></p><h3 id="总结">总结</h3><ul><li>在模板类型推导的时候，有引用特性的参数的引用特性会被忽略</li><li>在推导通用引用参数的时候，左值会被特殊处理</li><li>在推导按值传递的参数时候，const和volatile参数会被视为非const和非volatile</li><li>在模板类型推导的时候，参数如果是数组或者函数名称，他们会被退化成指针，除非是用在初始化引用类型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;item1-理解模板类型推导p9-p18&quot;&gt;Item1 理解模板类型推导（p9-p18）&lt;/h2&gt;
&lt;p&gt;C++98中，类型推导只发生在函数模板中。C++11中类型推导还会发生在大多数auto关键字和decltype表达式出现的地方，C++14还会发生在declt
      
    
    </summary>
    
      <category term="编程语言" scheme="http://natsu1211.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="读书笔记" scheme="http://natsu1211.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="http://natsu1211.com/tags/c/"/>
    
  </entry>
  
</feed>
