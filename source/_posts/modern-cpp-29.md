---
title: 读薄Effective Modern C++（条款29 假设移动操作是不存在、不廉价、不能用的)
date: 2019-06-05 01:15:55
tags:
- [C++]
- [Universal reference]
- [Rvalue reference]
categories:
- [PL, Tips]
- [Memo]
---

## 条款29 假设移动操作是不存在、不廉价、不能用的

对于古老的C++98代码库，移动操作并不总是存在的，因为当你声明了拷贝构造函数或析构函数，编译器就不会帮助自动生成移动构造函数。这时，没有理由期望C++11的性能比C++98好。

就算一些类型支持移动操作，比起拷贝操作，它们也不一定具有更高效率。比如std::array，不同于其他的标准库容器（将实际内容保存在堆上，容器内部只保持着指向堆的指针），
![](https://raw.githubusercontent.com/natsu1211/pics/master/item29-1.png)

std::array缺少这样的指针，数据直接存储在std::array对象中。因此移动std::array的效率和拷贝无二。
![](https://raw.githubusercontent.com/natsu1211/pics/master/item29-2.png)

因此在下面几种情况下，C++11的移动语义对你没好处：

- 没有移动操作。需要被移动的对象拒绝提供移动操作，结果是移动请求会变为拷贝。     
- 移动的速度不快。需要被移动的对象有移动操作，但是不比拷贝效率高。      
- 不能使用移动操作。在一些进行移动操作的上下文中，要求移动操作不能产生异常，但移动操作没有声明为noexcept。      
- 源对象是个左值。只有右值才有可能作为移动操作的源对象，除去极少数例外。       

当然，如果清楚的知道使用的类提供廉价的移动操作，然后使用的对象又处在可以调用移动操作的语境，你可以安全地依赖移动语义，用开销更小的移动操作替换掉拷贝操作。

## 总结

- 假设移动操作是不存在、不廉价、不能用的。
- 在知道类型或支持移动语义的代码中，不需要这个假设。