---
title: 读薄Effective Modern C++ (条款17 理解特殊成员函数的生成)
date: 2019-01-12 18:31:53
tags:
- [C++]
- [Special members]
categories:
- [PL, Tips]
- [Memo]
---

## 条款17 理解特殊成员函数的生成
正如大家所知，C++编译器会在特定条件下为类生成特殊的成员函数。C++98中有4种隐式生成的特殊成员函数，构造函数(constuctor)，析构函数(destructor)，拷贝构造函数(copy constructor)，拷贝赋值运算符(copy assignment operator)，从C++11开始又新增了移动构造函数(move constructor)，移动赋值运算符(move assignment operator)。      
他们的生成规则可用下图概括,       

![](https://raw.githubusercontent.com/natsu1211/pics/master/cpp%20implicit%20functions.jpg)

<!-- more -->

简单概括，        

- 默认构造函数：类中没有用户声明的构造函数时才会生成。
- 析构函数：类中没有用户声明的析构函数时才会生成。和C++98的规则的唯一的区别就是析构函数默认声明为noexcept（看条款14）。C++98的规则是基类的析构函数的虚函数的话，生成的析构函数也是虚函数。
- 拷贝构造函数：只有在类中缺乏用户声明的拷贝构造时才会生成。如果类中声明了移动操作，拷贝构造会被删除(delete)。当类中存在用户声明的拷贝赋值操作符或析构函数时，建议用户同时自己定义拷贝构造函数。
- 拷贝赋值运算符：只有在类中缺乏用户声明的拷贝赋值运算符时才会生成。如果类中声明了移动操作，拷贝赋值运算符会被删除。当类中存在用户声明的拷贝构造函数或析构函数时，建议用户同时自己定义拷贝赋值运算符。
- 移动构造函数和移动赋值运算符：只有在类中没有用户声明的拷贝操作、移动操作、析构函数时才会自动生成。

需要注意的是，移动构造函数和移动赋值运算符不会抑制互相的生成。这是C++98的标准，C++11为了保证代码的兼容性同样保持了这一点。而移动构造函数和移动赋值运算符则会，这是符合直觉的。类似的，当用户定义了析构函数的时候，拷贝构造函数/拷贝赋值运算符依然可能被隐式声明，而移动版本则不能。然而生成的拷贝构造函数/拷贝赋值运算符的行为很有可能是不符合我们要求的，所以即使编译器能够为我们声明，我们也应当尽量的显式声明（也就是图中标红，需要注意的坑）。     

自动生成的拷贝构造函数与移动构造函数所做的事很简单，比如析构函数只是简单的对指针类型的成员进行delete，默认拷贝构造函数和默认移动构造函数只是对类中的non-static成员做逐成员（memberwise）的拷贝或移动。当自动生成的函数的行为符合你的需求的时候，可以简单的将他们定义为`=default`。而当默认的行为不符合需求的时候，你自然需要自己来定义这些函数。        

由此可以引申出著名的“三大法则”，如果你声明了拷贝构造、拷贝赋值运算符、析构函数中的其中一个，你应该把这三个函数都声明。这是因为，需要自定义这些函数通常是由于某种资源管理的需求，并且memberwise的拷贝，移动和默认的delete不能满足需求。在C++11之后，三大法则就变成了五大法则，你有很大可能还需要同时自定义移动构造函数和移动赋值运算符。

最后需要注意的是，标准没有规定成员函数模板的存在会阻止编译器生成特殊成员函数。这意味着如果Widget是这样的：

```cpp
class Widget {
    ...
    template <typename T>
    Widget(const T& rhs);   

    template <typename T>
    Widget& operator=(const T& rhs);
    ...
};
```

编译器还是会为Widget生成拷贝构造函数和拷贝赋值运算符（假如条件满足），尽管这些模板可以被实例化来产生拷贝构造函数和拷贝赋值运算符的签名（当T是Widget的时候）。这种情况需要记住，在条款26中会说明它导致的重大后果。

## 总结

- 记住并理解特殊成员函数的生成条件
- 成员函数模板从来不会抑制特殊成员函数的生成



